// Generated by CoffeeScript 1.4.0
(function() {
  var Ajax, Invocation, Signal, Uid, addInvocation, addingCallback, addingInvocation, batch, exports, getClass, getClasses, invoke,
    __slice = [].slice,
    __hasProp = {}.hasOwnProperty;

  Signal = (function() {

    function Signal() {
      this.__listeners = [];
    }

    Signal.prototype.dispatch = function(data) {
      var handled_listeners, listener, result, results;
      results = (function() {
        var _i, _len, _ref, _results;
        _ref = this.__listeners;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          listener = _ref[_i];
          if (listener != null) {
            _results.push(typeof listener === "function" ? listener(data) : void 0);
          }
        }
        return _results;
      }).call(this);
      handled_listeners = ((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = results.length; _i < _len; _i++) {
          result = results[_i];
          if (result === true) {
            _results.push(result);
          }
        }
        return _results;
      })()).length;
      return handled_listeners === results.length && results.length > 0;
    };

    Signal.prototype.add = function(listener, preserve_order) {
      var idx, l, _i, _len, _ref;
      if (preserve_order == null) {
        preserve_order = false;
      }
      if (!preserve_order) {
        _ref = this.__listeners;
        for (idx = _i = 0, _len = _ref.length; _i < _len; idx = ++_i) {
          l = _ref[idx];
          if (!(l != null)) {
            this.__listeners[idx] = listener;
            return idx;
          }
        }
      }
      this.__listeners.push(listener);
      return this.__listeners.length - 1;
    };

    Signal.prototype.once = function(listener) {
      var registration,
        _this = this;
      return registration = this.add(function(data) {
        listener(data);
        return _this.remove(registration);
      });
    };

    Signal.prototype.remove = function() {
      var registration, registrations, _i, _len, _results;
      registrations = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      _results = [];
      for (_i = 0, _len = registrations.length; _i < _len; _i++) {
        registration = registrations[_i];
        _results.push(this.__listeners[registration] = void 0);
      }
      return _results;
    };

    return Signal;

  })();

  Ajax = (function() {
    var __xhrs;

    __xhrs = {};

    function Ajax(_arg) {
      this.type = _arg.type, this.url = _arg.url, this.callback = _arg.callback, this.headers = _arg.headers;
      if (window.XMLHttpRequest) {
        this.xhr = new XMLHttpRequest;
      } else {
        try {
          this.xhr = new ActiveXObject("Msxml2.XMLHTTP");
        } catch (e) {
          this.xhr = new ActiveXObject("Microsoft.XMLHTTP");
        }
      }
      __xhrs[this.xhr] = true;
    }

    Ajax.prototype.send = function(payload, callback) {
      var k, v, _ref, _ref1,
        _this = this;
      this.payload = payload;
      this.callback = (_ref = this.callback) != null ? _ref : callback;
      this.xhr.open(this.type, this.url);
      if (this.headers) {
        _ref1 = this.headers;
        for (k in _ref1) {
          if (!__hasProp.call(_ref1, k)) continue;
          v = _ref1[k];
          this.xhr.setRequestHeader(k, v);
        }
      }
      if (this.callback) {
        this.xhr.onreadystatechange = function() {
          if (_this.xhr.readyState === 4) {
            _this.callback(_this.xhr.status, _this.xhr.responseText, _this.xhr);
            return delete __xhrs[_this.xhr];
          }
        };
      }
      return this.xhr.send(this.payload);
    };

    Ajax.prototype.abort = function() {
      this.xhr.abort();
      return delete __xhrs[this.xhr];
    };

    Ajax.abortAll = function() {
      var xhr, _;
      for (xhr in __xhrs) {
        _ = __xhrs[xhr];
        if (typeof xhr.abort === "function") {
          xhr.abort();
        }
      }
      return __xhrs = {};
    };

    return Ajax;

  })();

  Invocation = (function() {

    function Invocation(__calls, __callbacks) {
      var _ref, _ref1;
      this.__calls = __calls;
      this.__callbacks = __callbacks;
      this.__calls = (_ref = this.__calls) != null ? _ref : [];
      this.__callbacks = (_ref1 = this.__callbacks) != null ? _ref1 : [];
    }

    Invocation.prototype.send = function(__done, __map) {
      var opts,
        _this = this;
      this.__done = __done;
      this.__map = __map;
      opts = {
        type: 'POST',
        url: '/',
        headers: {
          'Content-type': 'application/json; charset=utf-8'
        },
        callback: function(code, text) {
          var cb, idx, r, responses, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
          responses = JSON.parse(text === '' ? '{}' : text);
          if (_this.__map != null) {
            responses = (function() {
              var _i, _len, _results;
              _results = [];
              for (_i = 0, _len = responses.length; _i < _len; _i++) {
                r = responses[_i];
                _results.push(this.__map(r));
              }
              return _results;
            }).call(_this);
          }
          if (code === 200) {
            _ref = _this.__callbacks;
            for (idx = _i = 0, _len = _ref.length; _i < _len; idx = ++_i) {
              cb = _ref[idx];
              if (cb != null) {
                if (typeof cb.success === "function") {
                  cb.success(responses != null ? responses[idx] : void 0);
                }
              }
            }
          } else {
            _ref1 = _this.__callbacks;
            for (idx = _j = 0, _len1 = _ref1.length; _j < _len1; idx = ++_j) {
              cb = _ref1[idx];
              if (cb != null) {
                if (typeof cb.error === "function") {
                  cb.error(responses != null ? responses[idx] : void 0, code);
                }
              }
            }
          }
          _ref2 = _this.__callbacks;
          for (idx = _k = 0, _len2 = _ref2.length; _k < _len2; idx = ++_k) {
            cb = _ref2[idx];
            if (typeof cb === "function") {
              cb(responses != null ? responses[idx] : void 0, code);
            }
          }
          return typeof _this.__done === "function" ? _this.__done() : void 0;
        }
      };
      this.__ajax = new Ajax(opts);
      this.__ajax.send(JSON.stringify(this.__calls));
      return this;
    };

    Invocation.prototype.abort = function() {
      var _base;
      return typeof (_base = this.__ajax).abort === "function" ? _base.abort() : void 0;
    };

    return Invocation;

  })();

  Uid = (function() {

    function Uid() {}

    Uid.id = 0;

    Uid.getUid = function() {
      return this.id += 1;
    };

    return Uid;

  })();

  addingInvocation = new Signal;

  addingCallback = new Signal;

  addInvocation = function(cls, method, args, construct_args) {
    var call, handled, id,
      _this = this;
    id = Uid.getUid();
    call = [cls, method, args, construct_args];
    handled = addingInvocation.dispatch([call, id]);
    if (handled) {
      return function(cb) {
        return addingCallback.dispatch([cb, id]);
      };
    } else {
      return function(cb) {
        var invocation;
        invocation = new Invocation([call], [cb]);
        return invocation.send();
      };
    }
  };

  getClass = function(_arg) {
    var cls, method, methods, name, staticMethods, _fn, _fn1, _i, _j, _len, _len1;
    name = _arg.name, methods = _arg.methods, staticMethods = _arg.staticMethods;
    cls = (function() {

      function _Class() {
        var __construct_args;
        __construct_args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        this.__construct_args = __construct_args;
      }

      return _Class;

    })();
    cls.__name = name;
    if (methods != null) {
      _fn = function(method) {
        return cls.prototype[method] = function() {
          var args;
          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          return addInvocation(this.constructor.__name, method, args, this.__construct_args);
        };
      };
      for (_i = 0, _len = methods.length; _i < _len; _i++) {
        method = methods[_i];
        _fn(method);
      }
    }
    if (staticMethods != null) {
      _fn1 = function(method) {
        return cls[method] = function() {
          var args;
          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          return addInvocation(this.__name, method, args);
        };
      };
      for (_j = 0, _len1 = staticMethods.length; _j < _len1; _j++) {
        method = staticMethods[_j];
        _fn1(method);
      }
    }
    return cls;
  };

  getClasses = function(classSchemas) {
    var methods, name, staticMethods, _i, _len, _ref, _results;
    _results = [];
    for (_i = 0, _len = classSchemas.length; _i < _len; _i++) {
      _ref = classSchemas[_i], name = _ref[0], staticMethods = _ref[1], methods = _ref[2];
      _results.push(getClass({
        name: name,
        staticMethods: staticMethods,
        methods: methods
      }));
    }
    return _results;
  };

  batch = function(setup) {
    var call, callback, callbacks, calls, done, done_callback, invocation, map, map_callback, registration, registration2, _;
    done_callback = map_callback = null;
    done = function(cb) {
      return done_callback = cb;
    };
    map = function(cb) {
      return map_callback = cb;
    };
    calls = [];
    registration = addingInvocation.add(function(_arg) {
      var call, id, invoker;
      call = _arg[0], id = _arg[1], invoker = _arg[2];
      calls.push([call, id, invoker]);
      return true;
    });
    registration2 = addingCallback.add(function(_arg) {
      var call, call_id, call_invoker, callback, id, idx, invoker, _i, _len, _ref, _results;
      callback = _arg[0], id = _arg[1], invoker = _arg[2];
      _results = [];
      for (idx = _i = 0, _len = calls.length; _i < _len; idx = ++_i) {
        _ref = calls[idx], call = _ref[0], call_id = _ref[1], call_invoker = _ref[2];
        if (call_id === id && call_invoker === invoker) {
          calls[idx].push(callback);
          break;
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    });
    setup(done, map);
    addingInvocation.remove(registration);
    addingCallback.remove(registration2);
    callbacks = (function() {
      var _i, _len, _ref, _results;
      _results = [];
      for (_i = 0, _len = calls.length; _i < _len; _i++) {
        _ref = calls[_i], _ = _ref[0], _ = _ref[1], _ = _ref[2], callback = _ref[3];
        _results.push(callback);
      }
      return _results;
    })();
    calls = (function() {
      var _i, _len, _ref, _results;
      _results = [];
      for (_i = 0, _len = calls.length; _i < _len; _i++) {
        _ref = calls[_i], call = _ref[0], _ = _ref[1], _ = _ref[2], _ = _ref[3];
        _results.push(call);
      }
      return _results;
    })();
    invocation = new Invocation(calls, callbacks);
    return invocation.send(done_callback, map_callback);
  };

  invoke = function(_arg, cb) {
    var args, classname, construt_args, invocation, method;
    classname = _arg[0], method = _arg[1], args = _arg[2], construt_args = _arg[3];
    invocation = new Invocation([[classname, method, args, construt_args]], [cb]);
    return invocation.send();
  };

  exports = exports != null ? exports : this;

  exports.invoker = {
    Signal: Signal,
    getClass: getClass,
    getClasses: getClasses,
    batch: batch,
    invoke: invoke
  };

}).call(this);
